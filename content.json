{"meta":{"title":"free blog","subtitle":"技术博客","description":"","author":"Bruce","url":"https://bruce54110.github.io","root":"/"},"pages":[{"title":"about","date":"2024-02-01T09:11:07.000Z","updated":"2024-02-01T09:11:07.049Z","comments":true,"path":"about/index.html","permalink":"https://bruce54110.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-02-01T12:27:11.000Z","updated":"2024-02-01T12:28:40.125Z","comments":true,"path":"categories/index.html","permalink":"https://bruce54110.github.io/categories/index.html","excerpt":"","text":""},{"title":"主页","date":"2024-02-01T09:20:46.000Z","updated":"2024-02-01T09:20:46.114Z","comments":true,"path":"主页/index.html","permalink":"https://bruce54110.github.io/%E4%B8%BB%E9%A1%B5/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Bean 循环依赖详解","slug":"spring-circular-dependency","date":"2024-01-31T12:56:05.000Z","updated":"2024-02-02T07:04:17.136Z","comments":true,"path":"2024/01/31/spring-circular-dependency/","link":"","permalink":"https://bruce54110.github.io/2024/01/31/spring-circular-dependency/","excerpt":"","text":"什么是循环依赖？ 循环依赖就是循环引用，就是两个或多个bean相互之间的持有对方。比如CircleA引用CircleB，CircleB引用CircleC，CircleC引用CircleA。 graph LR; A-->B B-->C C-->A Spring如何解决循环依赖？ Spring容器循环依赖包括如下两种： 构造器循环依赖 setter循环依赖 构造器循环依赖，表示通过构造器注入的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常。 原型模式下的依赖检查，只有单例模式下才会尝试解决循环依赖，原型模式下直接抛出异常BeanCurrentlyInCreationException异常。 1234567AbstractBeanFactory抽象类：// Fail if we&#x27;re already creating this bean instance:// We&#x27;re assumably within a circular reference.if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName);&#125; 单例模式下，setter循环依赖可以解决(使用@Async的单例除外，特殊情况下会报错） 单例模式下，构造器循环依赖无法解决 原型模式下，循环依赖无法解决 Spring 循环依赖场景分析 不管是单例 Bean还是prototype Bean，注入Bean的逻辑起点都是在AbstractBeanFactory.java中的 getBean方法。 以a，b 两个bean互相依赖为例，假设Spring容器先加载 a 后加载 b，时序图如下： sequenceDiagram AbstractBeanFactory.java->>DefaultSingletonBeanRegistry.java:getBean(\"a\") AbstractBeanFactory.java->>DefaultSingletonBeanRegistry.java:getSingleton(\"a\", true) DefaultSingletonBeanRegistry.java ->> DefaultSingletonBeanRegistry.java:this.singletonFactories.get(\"a\")为空 DefaultSingletonBeanRegistry.java-->>AbstractBeanFactory.java: 返回 sharedInstance \"a\" 为空（缓存里没有） AbstractBeanFactory.java->>DefaultSingletonBeanRegistry.java: getSingleton(\"a\", ObjectFactory singletonFactory) DefaultSingletonBeanRegistry.java -->> DefaultSingletonBeanRegistry.java: singletonFactory.getObject() DefaultSingletonBeanRegistry.java->>AbstractAutowireCapableBeanFactory: createBean(\"a\", mbd, args) AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory: doCreateBean(\"a\", mbdToUse, args) AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:createBeanInstance(\"a\", mbd, args) 实例化 AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:addSingletonFactory(\"a\", singletonFactory) 添加三级缓存工厂方法 AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:populateBean，寻找注入所依赖的\"b\" AbstractAutowireCapableBeanFactory-->> AbstractBeanFactory.java: getBean(\"b\") AbstractBeanFactory.java->>DefaultSingletonBeanRegistry.java:getSingleton(\"b\", true) DefaultSingletonBeanRegistry.java-->>AbstractBeanFactory.java: 返回 sharedInstance \"b\" 为空（缓存里没有） AbstractBeanFactory.java->>DefaultSingletonBeanRegistry.java: getSingleton(\"b\", ObjectFactory singletonFactory) DefaultSingletonBeanRegistry.java -->> DefaultSingletonBeanRegistry.java: singletonFactory.getObject() DefaultSingletonBeanRegistry.java->>AbstractAutowireCapableBeanFactory: createBean(\"b\", mbd, args) AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory: doCreateBean(\"b\", mbdToUse, args) AbstractAutowireCapableBeanFactory-->> AbstractAutowireCapableBeanFactory:createBeanInstance(\"b\", mbd, args) 实例化 AbstractAutowireCapableBeanFactory-->> AbstractAutowireCapableBeanFactory:addSingletonFactory(\"b\", singletonFactory) 添加三级缓存工厂方法 AbstractAutowireCapableBeanFactory-->> AbstractAutowireCapableBeanFactory:populateBean，寻找注入所依赖的\"a\" AbstractAutowireCapableBeanFactory -->> AbstractBeanFactory.java: getBean(\"a\") AbstractBeanFactory.java->> DefaultSingletonBeanRegistry.java:getBean(\"a\") AbstractBeanFactory.java->>DefaultSingletonBeanRegistry.java:getSingleton(\"a\", true) DefaultSingletonBeanRegistry.java -->>DefaultSingletonBeanRegistry.java:this.singletonFactories.get(\"a\")（三级缓存有a值） DefaultSingletonBeanRegistry.java -->> DefaultSingletonBeanRegistry.java:singletonFactory.getObject() DefaultSingletonBeanRegistry.java->> AbstractAutowireCapableBeanFactory: getEarlyBeanReference 获取早期的Bean \"a\" AbstractAutowireCapableBeanFactory -->> AbstractAutowireCapableBeanFactory: 若有AOP，会提前处理AOP相关逻辑 AbstractAutowireCapableBeanFactory -->> DefaultSingletonBeanRegistry.java: exposedObject DefaultSingletonBeanRegistry.java -->>DefaultSingletonBeanRegistry.java: 把 Bean \"a\" 放到二级缓存，移除三级缓存 DefaultSingletonBeanRegistry.java -->> AbstractBeanFactory.java:返回提早暴露的Bean \"a\" AbstractBeanFactory.java ->> AbstractAutowireCapableBeanFactory: 返回Bean \"a\",将\"a\"注入到 \"b\"当中(b终于找到a了) AbstractAutowireCapableBeanFactory -->> AbstractAutowireCapableBeanFactory:initializeBean(\"b\", exposedObject, mbd)，有AOP的话，会在这里处理 AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:Object earlySingletonReference = getSingleton(\"b\", false) 为null，因为二级缓存中为空 AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:exposedObject != earlySingletonReference 返回 b AbstractAutowireCapableBeanFactory -->> DefaultSingletonBeanRegistry.java:返回 DefaultSingletonBeanRegistry.java -->> DefaultSingletonBeanRegistry.java:addSingleton(\"b\", singletonObject)，放到一级缓存中 DefaultSingletonBeanRegistry.java -->> AbstractBeanFactory.java: 返回b (getSingleton(\"b\", ObjectFactory singletonFactory)) AbstractBeanFactory.java ->> AbstractAutowireCapableBeanFactory: a终于找到了依赖的b AbstractAutowireCapableBeanFactory -->> AbstractAutowireCapableBeanFactory:initializeBean(\"a\", exposedObject, mbd)，有AOP的话会在此处理 AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:Object earlySingletonReference = getSingleton(\"a\", false)，这里返回 a 不是null，因为二级缓存里有a AbstractAutowireCapableBeanFactory-->>AbstractAutowireCapableBeanFactory:exposedObject = earlySingletonReference 返回 a AbstractAutowireCapableBeanFactory -->> AbstractBeanFactory.java:返回a 从上面的时序图可以看出主要的流程，涉及到 AbstractBeanFactory、DefaultSingletonBeanRegistry、AbstractAutowireCapableBeanFactory 三个类。 1org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.java 12345678910111213141516171819202122232425/** * Return the (raw) singleton object registered under the given name. * &lt;p&gt;Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or &#123;@code null&#125; if none found */ protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null); &#125; bean加载时，从一开始的 调用 getSingleton() 方法从单例缓存中获取说起。 这个方法中涉及到三个缓存： 12345678/** Cache of singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(64);/** Cache of singleton factories: bean name --&gt; ObjectFactory */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);/** Cache of early singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16); singletonObjects 一级缓存，存放最终版Bean earlySingletonObjects 二级缓存，存放单例工厂创建的对象 singletonFactories 三级缓存，存放单例工厂（是一个函数） 这就是我们常说的三级缓存，第一级是singletonObjects ，第二级是earlySingletonObjects ,第三级是 singletonFactories getSingleton()方法整个过程如下： 首先从单例对象缓存singletonObjects 中获取，如果没有，且通过isSingletonCurrentlyInCreation() 方法判断当前要获取的bean正在处于创建中，那么就从earlySingletonObjects 二级缓存中获取，如果还没有 则从singletonFactories 三级缓存中获取。获取到的话，就通过singletonFactory.getObject()获取对象，并将其加入到二级缓存当中，从三级缓存当中删除。 这时候肯定有疑问，缓存中的数据是从哪里来的呢？ 一直往下跟代码我们会发现doCreateBean() 方法 123456789101112131415sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); AbstractAutowireCapableBeanFactory 中： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */ @Override protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; // Make sure bean class is actually resolved at this point. resolveBeanClass(mbd, beanName); // Prepare method overrides. try &#123; mbd.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); &#125; Object beanInstance = doCreateBean(beanName, mbd, args); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; return beanInstance; &#125; doCreateBean()： 12345678910111213141516// Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName + &quot;&#x27; to allow for resolving potential circular references&quot;); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; 我们可以看到 earlySingletonExposure是true的时候，才会调用addSingletonFactory()将bean对象加入到三级缓存当中。 earlySingletonExposure 为true 的前提是： bean是单例的 bean 允许提前引用 当前bean正在创建当中 addSingletonFactory() 代码如下: 12345678910protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;); synchronized (this.singletonObjects) &#123; if (!this.singletonObjects.containsKey(beanName)) &#123; this.singletonFactories.put(beanName, singletonFactory); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125; &#125;&#125; 将bean添加到三级缓存，从二级缓存中删掉 那么一级缓存是在哪里添加的呢？ 前边我们看到的 doCreateBean() 方法其实来自匿名内部类 new ObjectFactory&lt;Object&gt;() &#123;&#125; 重写的getObject() 方法 12345678910111213141516171819// Create bean instance. if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; 在调用 getSingleton() 方法时， getSingleton() 方法中( DefaultSingletonBeanRegistry )，调用了上边重写的getObject() 方法后，后边调用了addSingleton(beanName, singletonObject); addSingleton(beanName, singletonObject) 方法如下： 1234567891011121314/** * Add the given singleton object to the singleton cache of this factory. * &lt;p&gt;To be called for eager registration of singletons. * @param beanName the name of the bean * @param singletonObject the singleton object */protected void addSingleton(String beanName, Object singletonObject) &#123; synchronized (this.singletonObjects) &#123; this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT)); this.singletonFactories.remove(beanName); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125;&#125; 添加到一级缓存，从二级缓存中删掉，从三级缓存中删掉，将已经创建成功的bean添加registeredSingletons 集合中。 总结 ​ 至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。所以我们基本上可以确定 Spring 解决循环依赖的方案了：Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中，代码在上文的**“addSingletonFactory() 代码”**），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 getObject() 获取了，也就是 getSingleton() 中的代码片段了。 ​ 以A，B两个Bean互相依赖为例，在获取A Bean的时候，发现三级缓存中都是空的，则走后续实例化Bean的逻辑，将自己的ObjectFactory放到三级缓存当中，再接着进行加载自己依赖的其他属性，这时候去加载B Bean，同样的流程，B Bean也将自己的ObjectFactory放入到三级缓存中，再接着加载自己依赖的A Bean。这时候从三级缓存中获取到 A Bean ，同时将获取到的Bean放到二级缓存中。继续走后面的初始化逻辑。这时B就加载到了早期的A Bean。A Bean 继续走后续逻辑就成了一个完整的Bean。 ​ 到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。最后来描述下就上面那个循环依赖 Spring 解决的过程：首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 ObjectFactory.getObject() 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。 参考 从源码层面深度剖析Spring循环依赖 | 京东云技术团队","categories":[{"name":"Java","slug":"Java","permalink":"https://bruce54110.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bruce54110.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://bruce54110.github.io/tags/Spring/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://bruce54110.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bruce54110.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://bruce54110.github.io/tags/Spring/"}]}